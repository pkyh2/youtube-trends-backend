# Docker 배포 설정 - 설계 의도

## 왜 Multi-stage Build인가?

**문제**: 단일 이미지에 개발 도구와 소스코드가 모두 포함되면 이미지 크기가 비대해짐

**해결**: Builder와 Production 스테이지를 분리하여 최종 이미지에는 실행에 필요한 파일만 포함
- 이미지 크기 50% 이상 감소
- 배포 속도 향상 및 스토리지 비용 절감
- 보안 강화 (소스코드 및 빌드 도구 제외)

## 왜 npm ci --only=production인가?

**문제**: `npm install`은 devDependencies까지 설치하여 불필요한 패키지 포함

**해결**: Production 환경에서는 TypeScript 컴파일러 등 개발 도구가 불필요
- 의존성 크기 감소
- 보안 취약점 노출 최소화
- 빌드 재현성 보장 (package-lock.json 기준)

## 왜 호스트 DB를 사용하는가?

**문제**: Docker 컨테이너로 DB를 운영하면 데이터 영속성 관리와 백업이 복잡해짐

**해결**: 서버만 컨테이너화하고 DB는 호스트에서 관리
- 데이터 안정성 보장 (컨테이너 재시작 시에도 데이터 유지)
- 기존 DB 인프라 활용 가능
- DB 백업 및 모니터링 전략을 기존 방식 유지
- 서버 재배포가 DB에 영향 없음

## 왜 Health Check인가?

**문제**: 컨테이너가 실행 중이어도 애플리케이션이 정상 작동하지 않을 수 있음

**해결**: `/health` 엔드포인트로 실제 서비스 가용성 확인
- 자동 재시작 트리거 (비정상 상태 감지 시)
- 로드밸런서 연동 시 헬스체크 기준 제공
- 배포 후 안정화 시간 확보 (start_period)

## 왜 .dockerignore인가?

**문제**: `COPY . .` 시 불필요한 파일(node_modules, .git 등)이 빌드 컨텍스트에 포함됨

**해결**: 빌드에 필요없는 파일 제외
- 빌드 컨텍스트 크기 감소 → 빌드 속도 향상
- 민감 정보(.env) 이미지 포함 방지
- Layer caching 효율성 증대

## 환경변수 관리 전략

**문제**: 컨테이너 이미지에 환경변수를 하드코딩하면 재빌드 없이 설정 변경 불가

**해결**: `.env` 파일로 분리하여 런타임 주입
- 환경별 설정 변경 용이 (개발/스테이징/프로덕션)
- 민감 정보 버전 관리 제외
- 동일 이미지로 다양한 환경 배포 가능
